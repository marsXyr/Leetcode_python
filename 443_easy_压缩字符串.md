# Leetcode 443 压缩字符串
***
### 题目描述

给定一组字符，使用原地算法将其压缩。

压缩后的长度必须始终小于或等于原数组长度。

数组的每个元素应该是长度为1 的**字符**（不是 int 整数类型）。

在完成**原地修改**输入数组后，返回数组的新长度。

**进阶：** 你能否仅使用O(1) 空间解决问题？

**示例1:**  

	输入：
	["a","a","b","b","c","c","c"]

	输出：
	返回6，输入数组的前6个字符应该是：["a","2","b","2","c","3"]

	说明：
	"aa"被"a2"替代。"bb"被"b2"替代。"ccc"被"c3"替代。
	
**示例2:**  

	输入：
	["a"]

	输出：
	返回1，输入数组的前1个字符应该是：["a"]

	说明：
	没有任何字符串被替代。
	
**示例3:**  

	输入：
	["a","b","b","b","b","b","b","b","b","b","b","b","b"]

	输出：
	返回4，输入数组的前4个字符应该是：["a","b","1","2"]。

	说明：
	由于字符"a"不重复，所以不会被压缩。"bbbbbbbbbbbb"被“b12”替代。
	注意每个数字在数组中都有它自己的位置。
	
**注意：**

1. 所有字符都有一个ASCII值在`[35, 126]`区间内。
2. `1 <= len(chars) <= 1000`。

### 考点

字符串

### 思路
倒序遍历数组 

### 代码
执行用时: **68ms**, 内存消耗: **13MB**。

```
class Solution:
    def compress(self, chars: List[str]) -> int:
        if len(chars) == 1:
            return 1
        i, num = len(chars) - 1, 1
        while i > 0:
            if chars[i] == chars[i-1]:
                num += 1
                del(chars[i])           
            else:
                if num > 1:
                    chars[i+1:i+1] = list(str(num))
                num = 1                
            i -= 1
        if num > 1:
            chars[1:1] = list(str(num))
        return len(chars)
```





